WEBVTT
Kind: captions
Language: zh-Hans

00:00:01.310 --> 00:00:08.269
[音乐]

00:00:14.760 --> 00:00:19.599
什么是计算机科学中的算法，算法是一组指令

00:00:19.599 --> 00:00:23.830
为了逐步解决一些问题，算法通常由

00:00:23.830 --> 00:00:27.970
电脑，但我们人类也有算法，例如您会如何

00:00:27.970 --> 00:00:31.840
如果您像我一样，就可以很好地计算房间中的人数

00:00:31.840 --> 00:00:36.399
可能一次指向每个人，然后从零开始计数一二

00:00:36.399 --> 00:00:40.660
三四等等等等，这实际上是一个算法，让我们尝试表达

00:00:40.660 --> 00:00:44.890
它在伪代码英语方面更正式，例如类似于

00:00:44.890 --> 00:00:51.100
编程语言让房间中每个人的n等于零set n等于n

00:00:51.100 --> 00:00:56.290
加1如何解释伪代码quelt第1行声明可以这么说

00:00:56.290 --> 00:01:00.910
名为n的变量并将其值初始化为0，这仅表示在

00:01:00.910 --> 00:01:04.479
算法开始时，要进行计数的值是

00:01:04.479 --> 00:01:08.560
毕竟，在开始计数之前，我们还没有计数0

00:01:08.560 --> 00:01:12.640
这个变量n只是一个约定，我现在几乎可以将其称为

00:01:12.640 --> 00:01:16.570
到des的一行标志着循环的开始，将重复执行一些步骤

00:01:16.570 --> 00:01:20.530
次数，因此在我们的示例中，我们正在采取的步骤是计算

00:01:20.530 --> 00:01:24.670
第2行下方的房间是第3行，它准确地描述了我们将如何进行

00:01:24.670 --> 00:01:29.470
计数缩进意味着重复的是第3行，所以

00:01:29.470 --> 00:01:33.580
伪代码是说，对于每个人，从0开始

00:01:33.580 --> 00:01:38.440
我们现在将n增加1的空间，此算法正确吗

00:01:38.440 --> 00:01:42.520
好吧，如果房间里有两个人，就让它起作用吧

00:01:42.520 --> 00:01:47.560
让我们在第一行中看到，对于这两个人，我们分别将n初始化为0

00:01:47.560 --> 00:01:52.659
将n递增1，因此在循环的第一个行程中，我们将n从0更新为1

00:01:52.659 --> 00:01:57.280
在同一循环的第二次行程中，我们将n从1更新为2，因此

00:01:57.280 --> 00:02:02.080
该算法的末尾n为2，这确实与房间中的人数相匹配

00:02:02.080 --> 00:02:06.040
到目前为止，尽管假设零为零，但情况如何呢？

00:02:06.040 --> 00:02:10.929
除了我以外，房间里的人都在第一行进行计数

00:02:10.929 --> 00:02:15.549
这次将n初始化为0，尽管第3行根本不执行

00:02:15.549 --> 00:02:19.810
不是房间里的人，所以n仍然为0，这确实与

00:02:19.810 --> 00:02:22.200
房间里的人数很简单，但是

00:02:22.200 --> 00:02:26.519
一次帮助一个人效率很低-不能肯定我们可以做得更好

00:02:26.519 --> 00:02:31.170
为什么不一次数两个人，而不是一二三四

00:02:31.170 --> 00:02:36.180
五六七八等等为什么不算两四六八等等

00:02:36.180 --> 00:02:40.920
它甚至听起来更快，可以肯定的是，我们可以在其中表达这种优化

00:02:40.920 --> 00:02:46.590
伪代码令n对房间中的每一对人都等于零，则n等于n

00:02:46.590 --> 00:02:50.160
再加上两个非常简单的更改权，而不是

00:02:50.160 --> 00:02:54.569
一次算一个人，而我们一次算一次两个人

00:02:54.569 --> 00:02:59.310
速度是上一个的两倍，但是它是正确的吗？

00:02:59.310 --> 00:03:04.049
第一行的房间里有两个人，我们将那对的n初始化为0

00:03:04.049 --> 00:03:09.239
然后我们将n增加2，因此通过此算法，结束n是2

00:03:09.239 --> 00:03:12.480
确实与房间中的人数匹配假设接下来有

00:03:12.480 --> 00:03:17.579
第一行中房间中的零人，我们像第三行之前将n初始化为0

00:03:17.579 --> 00:03:20.730
因为房间里没有人，所以根本不执行

00:03:20.730 --> 00:03:24.660
所以n保持为零，这确实与房间中的人数相匹配

00:03:24.660 --> 00:03:29.160
但是如果房间里只有三个人怎么办？

00:03:29.160 --> 00:03:34.650
让我们在第一行中看到，对于一对这样的人，我们将n初始化为0

00:03:34.650 --> 00:03:39.359
将n加2，但随后又没有另一对完整的人

00:03:39.359 --> 00:03:44.519
如此盲目的空间不再适用，因此通过此算法，结束n仍为2

00:03:44.519 --> 00:03:47.940
这确实是不正确的，据说这个算法有问题

00:03:47.940 --> 00:03:52.609
因为它有一个错误，让我们用一些新的伪代码来纠正，让n等于0

00:03:52.609 --> 00:03:59.010
对于房间中的每一对人，将n设置为n等于n加两个（如果有一个人）

00:03:59.010 --> 00:04:03.959
保持未配对的集合n等于n加一以解决该特定问题

00:04:03.959 --> 00:04:08.760
我们针对条件（否则称为分支）引入了

00:04:08.760 --> 00:04:13.290
如果有一个人我们无法与另一个人配对，那么执行

00:04:13.290 --> 00:04:17.639
这个房间里有一个或三个或任何奇数的人

00:04:17.639 --> 00:04:21.780
现在将数他们，我们能否做得更好，我们可以数三分之三，或者

00:04:21.780 --> 00:04:25.560
四分之一甚至五分之十甚至几十，它将变得有点困难

00:04:25.560 --> 00:04:29.810
指出到底是由计算机还是由人来执行

00:04:29.810 --> 00:04:32.900
算法只是一组指令，

00:04:32.900 --> 00:04:38.680
所有这些只是三个问题您将在一个小时内解决什么问题

00:04:38.680 --> 00:04:55.060
[音乐]

